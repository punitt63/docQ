/*
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package in.docq.keycloak.rest.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import in.docq.keycloak.rest.client.model.PolicyEnforcerConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.util.HashSet;
import java.util.Set;

import in.docq.keycloak.rest.client.JSON;

/**
 * InstallationAdapterConfig
 */
@javax.annotation.Generated(value = "in.docq.keycloak.rest.codegen.languages.JavaClientCodegen", date = "2025-02-08T16:05:02.219423+05:30[Asia/Kolkata]", comments = "Generator version: 7.11.0")
public class InstallationAdapterConfig {
  public static final String SERIALIZED_NAME_REALM = "realm";
  @SerializedName(SERIALIZED_NAME_REALM)
  @javax.annotation.Nullable
  private String realm;

  public static final String SERIALIZED_NAME_REALM_PUBLIC_KEY = "realm-public-key";
  @SerializedName(SERIALIZED_NAME_REALM_PUBLIC_KEY)
  @javax.annotation.Nullable
  private String realmPublicKey;

  public static final String SERIALIZED_NAME_AUTH_SERVER_URL = "auth-server-url";
  @SerializedName(SERIALIZED_NAME_AUTH_SERVER_URL)
  @javax.annotation.Nullable
  private String authServerUrl;

  public static final String SERIALIZED_NAME_SSL_REQUIRED = "ssl-required";
  @SerializedName(SERIALIZED_NAME_SSL_REQUIRED)
  @javax.annotation.Nullable
  private String sslRequired;

  public static final String SERIALIZED_NAME_BEARER_ONLY = "bearer-only";
  @SerializedName(SERIALIZED_NAME_BEARER_ONLY)
  @javax.annotation.Nullable
  private Boolean bearerOnly;

  public static final String SERIALIZED_NAME_RESOURCE = "resource";
  @SerializedName(SERIALIZED_NAME_RESOURCE)
  @javax.annotation.Nullable
  private String resource;

  public static final String SERIALIZED_NAME_PUBLIC_CLIENT = "public-client";
  @SerializedName(SERIALIZED_NAME_PUBLIC_CLIENT)
  @javax.annotation.Nullable
  private Boolean publicClient;

  public static final String SERIALIZED_NAME_VERIFY_TOKEN_AUDIENCE = "verify-token-audience";
  @SerializedName(SERIALIZED_NAME_VERIFY_TOKEN_AUDIENCE)
  @javax.annotation.Nullable
  private Boolean verifyTokenAudience;

  public static final String SERIALIZED_NAME_CREDENTIALS = "credentials";
  @SerializedName(SERIALIZED_NAME_CREDENTIALS)
  @javax.annotation.Nullable
  private Map<String, Object> credentials = new HashMap<>();

  public static final String SERIALIZED_NAME_USE_RESOURCE_ROLE_MAPPINGS = "use-resource-role-mappings";
  @SerializedName(SERIALIZED_NAME_USE_RESOURCE_ROLE_MAPPINGS)
  @javax.annotation.Nullable
  private Boolean useResourceRoleMappings;

  public static final String SERIALIZED_NAME_CONFIDENTIAL_PORT = "confidential-port";
  @SerializedName(SERIALIZED_NAME_CONFIDENTIAL_PORT)
  @javax.annotation.Nullable
  private Integer confidentialPort;

  public static final String SERIALIZED_NAME_POLICY_ENFORCER = "policy-enforcer";
  @SerializedName(SERIALIZED_NAME_POLICY_ENFORCER)
  @javax.annotation.Nullable
  private PolicyEnforcerConfig policyEnforcer;

  public InstallationAdapterConfig() {
  }

  public InstallationAdapterConfig realm(@javax.annotation.Nullable String realm) {
    this.realm = realm;
    return this;
  }

  /**
   * Get realm
   * @return realm
   */
  @javax.annotation.Nullable
  public String getRealm() {
    return realm;
  }

  public void setRealm(@javax.annotation.Nullable String realm) {
    this.realm = realm;
  }


  public InstallationAdapterConfig realmPublicKey(@javax.annotation.Nullable String realmPublicKey) {
    this.realmPublicKey = realmPublicKey;
    return this;
  }

  /**
   * Get realmPublicKey
   * @return realmPublicKey
   */
  @javax.annotation.Nullable
  public String getRealmPublicKey() {
    return realmPublicKey;
  }

  public void setRealmPublicKey(@javax.annotation.Nullable String realmPublicKey) {
    this.realmPublicKey = realmPublicKey;
  }


  public InstallationAdapterConfig authServerUrl(@javax.annotation.Nullable String authServerUrl) {
    this.authServerUrl = authServerUrl;
    return this;
  }

  /**
   * Get authServerUrl
   * @return authServerUrl
   */
  @javax.annotation.Nullable
  public String getAuthServerUrl() {
    return authServerUrl;
  }

  public void setAuthServerUrl(@javax.annotation.Nullable String authServerUrl) {
    this.authServerUrl = authServerUrl;
  }


  public InstallationAdapterConfig sslRequired(@javax.annotation.Nullable String sslRequired) {
    this.sslRequired = sslRequired;
    return this;
  }

  /**
   * Get sslRequired
   * @return sslRequired
   */
  @javax.annotation.Nullable
  public String getSslRequired() {
    return sslRequired;
  }

  public void setSslRequired(@javax.annotation.Nullable String sslRequired) {
    this.sslRequired = sslRequired;
  }


  public InstallationAdapterConfig bearerOnly(@javax.annotation.Nullable Boolean bearerOnly) {
    this.bearerOnly = bearerOnly;
    return this;
  }

  /**
   * Get bearerOnly
   * @return bearerOnly
   */
  @javax.annotation.Nullable
  public Boolean getBearerOnly() {
    return bearerOnly;
  }

  public void setBearerOnly(@javax.annotation.Nullable Boolean bearerOnly) {
    this.bearerOnly = bearerOnly;
  }


  public InstallationAdapterConfig resource(@javax.annotation.Nullable String resource) {
    this.resource = resource;
    return this;
  }

  /**
   * Get resource
   * @return resource
   */
  @javax.annotation.Nullable
  public String getResource() {
    return resource;
  }

  public void setResource(@javax.annotation.Nullable String resource) {
    this.resource = resource;
  }


  public InstallationAdapterConfig publicClient(@javax.annotation.Nullable Boolean publicClient) {
    this.publicClient = publicClient;
    return this;
  }

  /**
   * Get publicClient
   * @return publicClient
   */
  @javax.annotation.Nullable
  public Boolean getPublicClient() {
    return publicClient;
  }

  public void setPublicClient(@javax.annotation.Nullable Boolean publicClient) {
    this.publicClient = publicClient;
  }


  public InstallationAdapterConfig verifyTokenAudience(@javax.annotation.Nullable Boolean verifyTokenAudience) {
    this.verifyTokenAudience = verifyTokenAudience;
    return this;
  }

  /**
   * Get verifyTokenAudience
   * @return verifyTokenAudience
   */
  @javax.annotation.Nullable
  public Boolean getVerifyTokenAudience() {
    return verifyTokenAudience;
  }

  public void setVerifyTokenAudience(@javax.annotation.Nullable Boolean verifyTokenAudience) {
    this.verifyTokenAudience = verifyTokenAudience;
  }


  public InstallationAdapterConfig credentials(@javax.annotation.Nullable Map<String, Object> credentials) {
    this.credentials = credentials;
    return this;
  }

  public InstallationAdapterConfig putCredentialsItem(String key, Object credentialsItem) {
    if (this.credentials == null) {
      this.credentials = new HashMap<>();
    }
    this.credentials.put(key, credentialsItem);
    return this;
  }

  /**
   * Get credentials
   * @return credentials
   */
  @javax.annotation.Nullable
  public Map<String, Object> getCredentials() {
    return credentials;
  }

  public void setCredentials(@javax.annotation.Nullable Map<String, Object> credentials) {
    this.credentials = credentials;
  }


  public InstallationAdapterConfig useResourceRoleMappings(@javax.annotation.Nullable Boolean useResourceRoleMappings) {
    this.useResourceRoleMappings = useResourceRoleMappings;
    return this;
  }

  /**
   * Get useResourceRoleMappings
   * @return useResourceRoleMappings
   */
  @javax.annotation.Nullable
  public Boolean getUseResourceRoleMappings() {
    return useResourceRoleMappings;
  }

  public void setUseResourceRoleMappings(@javax.annotation.Nullable Boolean useResourceRoleMappings) {
    this.useResourceRoleMappings = useResourceRoleMappings;
  }


  public InstallationAdapterConfig confidentialPort(@javax.annotation.Nullable Integer confidentialPort) {
    this.confidentialPort = confidentialPort;
    return this;
  }

  /**
   * Get confidentialPort
   * @return confidentialPort
   */
  @javax.annotation.Nullable
  public Integer getConfidentialPort() {
    return confidentialPort;
  }

  public void setConfidentialPort(@javax.annotation.Nullable Integer confidentialPort) {
    this.confidentialPort = confidentialPort;
  }


  public InstallationAdapterConfig policyEnforcer(@javax.annotation.Nullable PolicyEnforcerConfig policyEnforcer) {
    this.policyEnforcer = policyEnforcer;
    return this;
  }

  /**
   * Get policyEnforcer
   * @return policyEnforcer
   */
  @javax.annotation.Nullable
  public PolicyEnforcerConfig getPolicyEnforcer() {
    return policyEnforcer;
  }

  public void setPolicyEnforcer(@javax.annotation.Nullable PolicyEnforcerConfig policyEnforcer) {
    this.policyEnforcer = policyEnforcer;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InstallationAdapterConfig installationAdapterConfig = (InstallationAdapterConfig) o;
    return Objects.equals(this.realm, installationAdapterConfig.realm) &&
        Objects.equals(this.realmPublicKey, installationAdapterConfig.realmPublicKey) &&
        Objects.equals(this.authServerUrl, installationAdapterConfig.authServerUrl) &&
        Objects.equals(this.sslRequired, installationAdapterConfig.sslRequired) &&
        Objects.equals(this.bearerOnly, installationAdapterConfig.bearerOnly) &&
        Objects.equals(this.resource, installationAdapterConfig.resource) &&
        Objects.equals(this.publicClient, installationAdapterConfig.publicClient) &&
        Objects.equals(this.verifyTokenAudience, installationAdapterConfig.verifyTokenAudience) &&
        Objects.equals(this.credentials, installationAdapterConfig.credentials) &&
        Objects.equals(this.useResourceRoleMappings, installationAdapterConfig.useResourceRoleMappings) &&
        Objects.equals(this.confidentialPort, installationAdapterConfig.confidentialPort) &&
        Objects.equals(this.policyEnforcer, installationAdapterConfig.policyEnforcer);
  }

  @Override
  public int hashCode() {
    return Objects.hash(realm, realmPublicKey, authServerUrl, sslRequired, bearerOnly, resource, publicClient, verifyTokenAudience, credentials, useResourceRoleMappings, confidentialPort, policyEnforcer);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InstallationAdapterConfig {\n");
    sb.append("    realm: ").append(toIndentedString(realm)).append("\n");
    sb.append("    realmPublicKey: ").append(toIndentedString(realmPublicKey)).append("\n");
    sb.append("    authServerUrl: ").append(toIndentedString(authServerUrl)).append("\n");
    sb.append("    sslRequired: ").append(toIndentedString(sslRequired)).append("\n");
    sb.append("    bearerOnly: ").append(toIndentedString(bearerOnly)).append("\n");
    sb.append("    resource: ").append(toIndentedString(resource)).append("\n");
    sb.append("    publicClient: ").append(toIndentedString(publicClient)).append("\n");
    sb.append("    verifyTokenAudience: ").append(toIndentedString(verifyTokenAudience)).append("\n");
    sb.append("    credentials: ").append(toIndentedString(credentials)).append("\n");
    sb.append("    useResourceRoleMappings: ").append(toIndentedString(useResourceRoleMappings)).append("\n");
    sb.append("    confidentialPort: ").append(toIndentedString(confidentialPort)).append("\n");
    sb.append("    policyEnforcer: ").append(toIndentedString(policyEnforcer)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("realm");
    openapiFields.add("realm-public-key");
    openapiFields.add("auth-server-url");
    openapiFields.add("ssl-required");
    openapiFields.add("bearer-only");
    openapiFields.add("resource");
    openapiFields.add("public-client");
    openapiFields.add("verify-token-audience");
    openapiFields.add("credentials");
    openapiFields.add("use-resource-role-mappings");
    openapiFields.add("confidential-port");
    openapiFields.add("policy-enforcer");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to InstallationAdapterConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!InstallationAdapterConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in InstallationAdapterConfig is not found in the empty JSON string", InstallationAdapterConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!InstallationAdapterConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `InstallationAdapterConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("realm") != null && !jsonObj.get("realm").isJsonNull()) && !jsonObj.get("realm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `realm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("realm").toString()));
      }
      if ((jsonObj.get("realm-public-key") != null && !jsonObj.get("realm-public-key").isJsonNull()) && !jsonObj.get("realm-public-key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `realm-public-key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("realm-public-key").toString()));
      }
      if ((jsonObj.get("auth-server-url") != null && !jsonObj.get("auth-server-url").isJsonNull()) && !jsonObj.get("auth-server-url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `auth-server-url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("auth-server-url").toString()));
      }
      if ((jsonObj.get("ssl-required") != null && !jsonObj.get("ssl-required").isJsonNull()) && !jsonObj.get("ssl-required").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ssl-required` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ssl-required").toString()));
      }
      if ((jsonObj.get("resource") != null && !jsonObj.get("resource").isJsonNull()) && !jsonObj.get("resource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resource").toString()));
      }
      // validate the optional field `policy-enforcer`
      if (jsonObj.get("policy-enforcer") != null && !jsonObj.get("policy-enforcer").isJsonNull()) {
        PolicyEnforcerConfig.validateJsonElement(jsonObj.get("policy-enforcer"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!InstallationAdapterConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'InstallationAdapterConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<InstallationAdapterConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(InstallationAdapterConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<InstallationAdapterConfig>() {
           @Override
           public void write(JsonWriter out, InstallationAdapterConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public InstallationAdapterConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of InstallationAdapterConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of InstallationAdapterConfig
   * @throws IOException if the JSON string is invalid with respect to InstallationAdapterConfig
   */
  public static InstallationAdapterConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, InstallationAdapterConfig.class);
  }

  /**
   * Convert an instance of InstallationAdapterConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

